package proof_test

import (
	"encoding/hex"
	"encoding/json"
	"os"
	"testing"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/trie"
	"github.com/stretchr/testify/suite"
	"github.com/sygmaprotocol/sygma-inclusion-prover/chains/evm/proof"
	"github.com/sygmaprotocol/sygma-inclusion-prover/mock"
	"go.uber.org/mock/gomock"
)

type ReceiptProofTestSuite struct {
	suite.Suite

	prover    *proof.ReceiptProver
	txFetcher *mock.MockTransactionFetcher
	receipt   *types.Receipt
}

func TestRunReceiptProofTestSuite(t *testing.T) {
	suite.Run(t, new(ReceiptProofTestSuite))
}

func (s *ReceiptProofTestSuite) SetupTest() {
	ctrl := gomock.NewController(s.T())
	s.txFetcher = mock.NewMockTransactionFetcher(ctrl)

	transactions := []*types.Transaction{}
	transactionBytes, err := os.ReadFile("./stubs/transactions.json")
	if err != nil {
		panic(err)
	}
	err = json.Unmarshal(transactionBytes, &transactions)
	if err != nil {
		panic(err)
	}
	block := types.NewBlock(
		&types.Header{},
		transactions,
		[]*types.Header{},
		[]*types.Receipt{},
		trie.NewStackTrie(nil))
	s.txFetcher.EXPECT().BlockByHash(gomock.Any(), gomock.Any()).Return(block, nil)

	siblings := []*types.Receipt{}
	siblingBytes, err := os.ReadFile("./stubs/siblings.json")
	if err != nil {
		panic(err)
	}
	err = json.Unmarshal(siblingBytes, &siblings)
	if err != nil {
		panic(err)
	}
	for _, tx := range block.Transactions() {
		for _, sibling := range siblings {
			if sibling.TxHash == tx.Hash() {
				s.txFetcher.EXPECT().TransactionReceipt(gomock.Any(), tx.Hash()).Return(sibling, nil)
				break
			}
		}

	}

	receipt := &types.Receipt{}
	receiptBytes, err := os.ReadFile("./stubs/receipt.json")
	if err != nil {
		panic(err)
	}
	err = receipt.UnmarshalJSON(receiptBytes)
	if err != nil {
		panic(err)
	}
	s.receipt = receipt
	s.txFetcher.EXPECT().TransactionReceipt(gomock.Any(), common.HexToHash("0xf3775a2e822ed9a51ddf1c0e75a9d4e258bafb9f1005f784a29dd22d9a9e4c72")).Return(receipt, nil)
	s.prover = proof.NewReceiptProver(s.txFetcher)
}

func (s *ReceiptProofTestSuite) Test_ReceiptProof() {
	expectedProof := []string{
		"f90131a0c0852d232132518b54dd7197882d9e935d0c586630315502ea9087c80a280a4aa0c786ea07b376475c261945f76b291ef2291c0e8afcb3aa77bc8df11fe5ce83b7a082e69e76de78ab7f890824d2fec186e28d65c6a39321aad0f63d6e3cf20278f0a004c3aa9cb33314230d3cdb624bf0d02fe9db27fbe748668c27d24f2e92ac069aa07fa699ba011d2457f3c9fe7515b50d688a8a211e8d14631835da76fa8e3dc23fa03093e4cfaf02e0eda0312f37e4f4de46263bdf001c621321ac38e1d0ac215989a04c4ff35cb0a2a43d3a1b7e1450168c080d2242120039a81e35f295f4f6739918a054dbcf8df94a70cb5b9ad9be77b90fbae48f63005ca86918bd66249742820aa0a0a11ddc6dc99288b29bf212b56cedc76a941f202555b7cb7161abd6168565fbb78080808080808080",
		"f90211a036c8dd014d41a84b0efcef7e02fa420ef1dc34fd781f187daceefbfd476b916ba07980a8ae2942a67656df2bf631e9c78c598aeec6aa5be0f2eefc9562e7d69e0fa0e20f411ea0579f779c42c35673afe540db5a0d324ee009d58a5e1132ead3cdb6a061169095098f5ae6e41d35af9da0a11619030dc4fe32c6d12743d68de262c804a03113d87d11de547207f6c54b3ef83cf672b4741aa0ce73b7662a8befd147f945a04d03beee945cc854aea4159d2f414a10c5230a47eef16021149b8d527636262da0780eb0c473f5cd4c88d6c48cf685eaa9b3125de03900da62c0db8391c6c47fdaa05c04a214548479b72736f0d24a0367eed759dcb931062facfbf68b324ec0e6c5a0f7935e6d8fe2ae4be74893e3b7fd7c88ce2e7912bf5006ca23382f408839681da0067bf7e33c25513f6e3d0883cae48289ce30d80fa75f17c8ea6e209010a6a279a0f94eb7182a1759c8ae7c5e91778deaf32ce1ce224c58fbb77e367c3e524f7b20a0187b6c65ff7105512b238f6bac94ff9b171a0df65551af2825b605bbd08488c7a018b8847ecc7cce607f829daf31898077f92b14955298db7c84fd308ecfc098bea029456e75b5b5da9a741c3e3fce6ae74321e95a21c973b3c34666062ddb414745a00a6695d1c6ad6d4c107b25a534836c719fbe384e164b2110797dad27f5089cd5a0bf57b42dad8534c68a3c9fec4dc8881e60995468d88969b8403c9d20a63e543780",
		"f9035220b9034e02f9034a01833b0341b9010000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000400000000000000000000080000000000000000000000000000000000000000000000000000010000080001000000000000f9023ff9023c9421eab033c7d2df6a67aef6c5bda9a7f151eb9f52f842a0218247aabc759e65b5bb92ccc074f9d62cd187259f2a0984c3c9cf91f67ff7cfa0d02f50cb1a33062c3f4e13930f7677c38b0fc4fab1edc92408a6deb3d7979a1fb901e00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000027d800000000000000000000000000000000000000000000000000000000000000010000000000000000000000001c3a03d04c026b1f4b4208d2ce053c5686e6fb8d000000000000000000000000ba9165973963a6e5608f03b9648c34a737e48f68000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000180000000000000000000000000000000000000000000000000000000000000000b48656c6c6f20776f726c64000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000ba9165973963a6e5608f03b9648c34a737e48f68"}

	p, err := s.prover.ReceiptProof(common.HexToHash("0xf3775a2e822ed9a51ddf1c0e75a9d4e258bafb9f1005f784a29dd22d9a9e4c72"))

	s.Nil(err)
	for i, leaf := range p {
		s.Equal(expectedProof[i], hex.EncodeToString(leaf))
	}
}
